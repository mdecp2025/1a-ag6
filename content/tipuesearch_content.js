var tipuesearch = {"pages": [{'title': 'About', 'text': '學習心得報告 (60%) \xa0 - MS Teams 線上參與， 6人一組 每三週發表學習心得。 \n w3、w7、w10、w14、w17、w18 \n 學習心得報告主題: \n w3: 什麼是 git, GitHub, gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？ ( 動態模擬 ) \n w7: Brython 是什麼？如何在瀏覽器配置 Brython 環境？ Brython 能做什麼？ ( Brython , \xa0 Examples ) \n w10: 如何在瀏覽器中模擬機器人作動？ ( 機器人作動 ) \n w14: 在瀏覽器中模擬機器人作動的目的是什麼？ ( otto_robot.7z ,\xa0 Plotter ,\xa0 open_duck_mini.7z \xa0 , https://webots.cloud/AcTNYs0 ) \n w17 ( 1b 採 Youtube 影片簡報 ): 計算機程式課程學到了什麼？ \n w18: 課程總結 \n 個人與分組網站維護 (40%) \xa0 - 每週至少兩次推送與課程進度相關的學習內容與心得。 \n w9 期中自評、w18 期末自評... \n \n \n \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'WH3', 'text': '', 'tags': '', 'url': 'WH3.html'}, {'title': '定義', 'text': 'git 是一套「分散式版本控制系統」，用來： \n \n \n 追蹤檔案的修改歷史 \n \n \n 協助多人協作開發 \n \n \n 可以隨時回到過去版本 \n \n \n \n GitHub 是一個「git 版本庫的雲端平台」 \n gist 是 GitHub 提供的「小型 git 專案」 \n cmsimde 是一個：結合 git + GitHub + 網頁 CMS 的「課程/專案管理系統」 \n \n \n \n 工具 \n 角色 \n 功能 \n \n \n \n \n git \n 核心工具 \n 版本控制 \n \n \n GitHub \n 雲端平台 \n 備份、協作 \n \n \n gist \n 輕量版 GitHub \n 小程式、筆記 \n \n \n cmsimde \n 整合系統 \n 教學 + 模擬 \n \n \n \n', 'tags': '', 'url': '定義.html'}, {'title': '為什麼要使用這些工具？', 'text': '因為現代學習、工程與動態模擬需要：可追蹤、可回復、可協作、可展示，而這些工具正好分工完成這四件事。 \n \n', 'tags': '', 'url': '為什麼要使用這些工具？.html'}, {'title': 'WH3心得', 'text': '41423108:上課一開始覺得 Git、GitHub 很複雜，但實際操作後才發現可以清楚記錄每次程式修改的內容，對做動態模擬很有幫助。搭配 Gist 分享小段程式碼，以及用 cmsimde 整理學習成果，讓我比較不會亂掉，也更清楚自己學到了什麼。 \n 41423109:透過學習  git 、 GitHub 、 gist  與  cmsimde ，我了解如何有效管理程式版本與專案內容。這些工具不但能保存修改紀錄，也能方便分享與協作，讓學習與開發流程更有系統性，也更接近實際業界的做法。 \n 41423103: git 給予容錯的勇氣，GitHub 拓展協作的視野，而 cmsimde 則將這些技術轉化為有系統的教學力，實現了從個人開發到數位管理的全方位進化。 \n', 'tags': '', 'url': 'WH3心得.html'}, {'title': 'WH7', 'text': '', 'tags': '', 'url': 'WH7.html'}, {'title': 'Brython 是什麼？', 'text': 'Brython 是一個讓 Python 程式碼能直接在瀏覽器中執行的工具，透過將 Python 轉譯為 JavaScript 來運作。 \n 在瀏覽器中配置 Brython，只需在 HTML 中引入 Brython 的 JS 檔案，並使用  type="text/python"  撰寫 Python 程式即可。 \n \n \n \n \n \n \n \n \n Brython 能操作 DOM、處理事件、與瀏覽器 API 互動，適合用於互動式網頁、教學與小型前端應用。 \n \n \n \n \n \n', 'tags': '', 'url': 'Brython 是什麼？.html'}, {'title': 'WH7心得', 'text': '41423108:這堂課讓我第一次知道原來 Python 也可以在瀏覽器裡跑，不一定只能寫後端。用 Brython 寫網頁時，看到自己寫的 Python 能直接改變網頁內容，覺得滿有趣也比較好理解。 \n 41423101:對初學者來說，Brython 很友善，只要會一點 Python，就能在網頁上看到成果，不用懂太多其他技術，能增加學習信心，也讓寫程式變得更有趣。 \n 41423109:透過  Brython ，我可以用熟悉的  Python  語法在瀏覽器中開發網頁功能，不需要額外安裝環境。這讓我更容易理解前端程式的運作方式，也提升了學習網頁程式設計的效率。 \n 41423103: 學習 Brython 讓我驚艷於 Python 在前端的潛力：它打破了瀏覽器只能運行 JS 的限制，讓網頁 DOM 操作變得直覺且優雅，是 Python 學習者進入互動式網頁與科學模擬的最佳路徑。 \n', 'tags': '', 'url': 'WH7心得.html'}, {'title': 'WH10', 'text': '', 'tags': '', 'url': 'WH10.html'}, {'title': '如何在瀏覽器中模擬機器人作動？', 'text': '要在瀏覽器中模擬機器人，通常結合了  Brython  的邏輯控制與  SVG  或  Canvas  的圖形渲染。 \n 模擬步驟： 先繪製機器人， 使用 HTML5 的 <canvas> 標籤作為畫布。接著物理邏輯， 在 Python 中編寫運動學公式（例如 v = d/t 或更複雜的連桿運動方程式）。最後動畫循環， 使用 Brython 的 browser.timer 模組，不斷更新機器人的位置座標並重繪畫面。 \n', 'tags': '', 'url': '如何在瀏覽器中模擬機器人作動？.html'}, {'title': '上課模擬', 'text': '\n from browser import document, html, timer\n\nCELL_SIZE = 40\nWALL_THICKNESS = 6\nIMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"\n\nclass World:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n        self.layers = self._create_layers()\n        self._init_html()\n        self._draw_grid()\n        self._draw_walls()\n    def _create_layers(self):\n        return {\n            "grid": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),\n            "walls": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),\n            "objects": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),\n            "robots": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),\n        }\n\n    def _init_html(self):\n        container = html.DIV(style={\n            "position": "relative",\n            "width": f"{self.width * CELL_SIZE}px",\n            "height": f"{self.height * CELL_SIZE}px"\n        })\n        for z, canvas in enumerate(self.layers.values()):\n            canvas.style = {\n                "position": "absolute",\n                "top": "0px",\n                "left": "0px",\n                "zIndex": str(z)\n            }\n            container <= canvas\n        document["brython_div1"].clear()\n        document["brython_div1"] <= container\n    def _draw_grid(self):\n        ctx = self.layers["grid"].getContext("2d")\n        ctx.strokeStyle = "#cccccc"\n        for i in range(self.width + 1):\n            ctx.beginPath()\n            ctx.moveTo(i * CELL_SIZE, 0)\n            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)\n            ctx.stroke()\n        for j in range(self.height + 1):\n            ctx.beginPath()\n            ctx.moveTo(0, j * CELL_SIZE)\n            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)\n            ctx.stroke()\n\n    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0):\n        img = html.IMG()\n        img.src = src\n        def onload(evt):\n            px = x * CELL_SIZE + offset_x\n            py = (self.height - 1 - y) * CELL_SIZE + offset_y\n            ctx.drawImage(img, px, py, w, h)\n        img.bind("load", onload)\n    def _draw_walls(self):\n        ctx = self.layers["walls"].getContext("2d")\n        for x in range(self.width):\n            # 北牆：最上方（貼在頂格子正上緣）\n            self._draw_image(ctx, IMG_PATH + "north.png", x, self.height - 1,\n                             CELL_SIZE, WALL_THICKNESS, offset_y=0)\n            # 南牆：最下方（貼在底格子正下緣）\n            self._draw_image(ctx, IMG_PATH + "north.png", x, 0,\n                             CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)\n        for y in range(self.height):\n            # 西牆：最左邊（貼格子內側左緣）\n            self._draw_image(ctx, IMG_PATH + "east.png", 0, y,\n                             WALL_THICKNESS, CELL_SIZE, offset_x=0)\n            # 東牆：最右邊（貼格子內側右緣）\n            self._draw_image(ctx, IMG_PATH + "east.png", self.width - 1, y,\n                             WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)\n\n    def robot(self, x, y):\n        ctx = self.layers["robots"].getContext("2d")\n        self._draw_image(ctx, IMG_PATH + "blue_robot_e.png", x - 1, y - 1,\n                         CELL_SIZE, CELL_SIZE)\n\nclass AnimatedRobot:\n    def __init__(self, world, x, y):\n        self.world = world\n        self.x = x - 1\n        self.y = y - 1\n        self.facing = "E"\n        self.facing_order = ["E", "N", "W", "S"]\n        self.robot_ctx = world.layers["robots"].getContext("2d")\n        self.trace_ctx = world.layers["objects"].getContext("2d")\n        self.queue = []\n        self.running = False\n        self._draw_robot()\n\n    def _robot_image(self):\n        return {\n            "E": "blue_robot_e.png",\n            "N": "blue_robot_n.png",\n            "W": "blue_robot_w.png",\n            "S": "blue_robot_s.png"\n        }[self.facing]\n\n    def _draw_robot(self):\n        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)\n        self.world._draw_image(self.robot_ctx, IMG_PATH + self._robot_image(),\n                               self.x, self.y, CELL_SIZE, CELL_SIZE)\n\n    def _draw_trace(self, from_x, from_y, to_x, to_y):\n        ctx = self.trace_ctx\n        ctx.strokeStyle = "#d33"\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        fx = from_x * CELL_SIZE + CELL_SIZE / 2\n        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2\n        tx = to_x * CELL_SIZE + CELL_SIZE / 2\n        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2\n        ctx.moveTo(fx, fy)\n        ctx.lineTo(tx, ty)\n        ctx.stroke()\n\n    def move(self, steps):\n        def action(next_done):\n            def step():\n                nonlocal steps\n                if steps == 0:\n                    next_done()\n                    return\n                from_x, from_y = self.x, self.y\n                dx, dy = 0, 0\n                if self.facing == "E":\n                    dx = 1\n                elif self.facing == "W":\n                    dx = -1\n                elif self.facing == "N":\n                    dy = 1\n                elif self.facing == "S":\n                    dy = -1\n                next_x = self.x + dx\n                next_y = self.y + dy\n    \n                # ✅ 邊界檢查\n                if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:\n                    self.x, self.y = next_x, next_y\n                    self._draw_trace(from_x, from_y, self.x, self.y)\n                    self._draw_robot()\n                    steps -= 1\n                    timer.set_timeout(step, 200)\n                else:\n                    print("🚨 已經撞牆，停止移動！")\n                    next_done()\n            step()\n        self.queue.append(action)\n        self._run_queue()\n\n    def turn_left(self):\n        def action(done):\n            idx = self.facing_order.index(self.facing)\n            self.facing = self.facing_order[(idx + 1) % 4]\n            self._draw_robot()\n            timer.set_timeout(done, 300)\n        self.queue.append(action)\n        self._run_queue()\n\n    def _run_queue(self):\n        if self.running or not self.queue:\n            return\n        self.running = True\n        action = self.queue.pop(0)\n        action(lambda: self._done())\n\n    def _done(self):\n        self.running = False\n        self._run_queue()\n\n                         \nw = World(10, 10)    # 建立 10x10 的世界\nw.robot(1, 1)        # 在 (1,1) 放置一台 robot\n\nr = AnimatedRobot(w, 1, 1)\nr.move(9)  # robot 動畫式向右走 5 步，途中留下 trace 線\nr.turn_left()\nr.move(9)\nr.turn_left()\nr.move(9)\nr.turn_left()\nr.move(9) \n \n', 'tags': '', 'url': '上課模擬.html'}, {'title': 'WH10心得', 'text': '41423108:以前覺得 Python 只能跑數據，沒想到加了 Brython 就能直接在網頁上控制機器人動起來，這點讓我覺得很酷！雖然剛開始在調校畫布座標跟物理公式時卡了一下，但用 Python 寫邏輯真的比 JS 直覺很多。 \n 41423101:我覺得用 Brython 在瀏覽器模擬機器人很有趣，把數學公式變成會動的畫面，能更清楚理解機器人的運動原理，也提升學習動力。 \n 41423109: 透過 Brython 將 Python 應用在瀏覽器中進行機器人模擬，讓我發現程式與數學可以結合成直觀的動態畫面。這種即時看到結果的學習方式，不但加深我對運動原理的理解，也讓程式設計變得更有成就感。 \n \n', 'tags': '', 'url': 'WH10心得.html'}, {'title': 'WH14', 'text': '', 'tags': '', 'url': 'WH14.html'}, {'title': '在瀏覽器中模擬機器人作動的目的是什麼？', 'text': '主要的目的是為了「降低門檻」與「提高溝通效率」。具體來說拆解成以下幾個關鍵點 \n 1. 零成本的快速驗證 (Rapid Prototyping) 在現實中測試機器人，最怕程式碼邏輯出錯導致硬體碰撞或馬達燒毀。在瀏覽器中模擬，可以先在虛擬環境驗證演算法，確認運動軌跡正確後再移植到實體機器上。 \n 2. 極致的跨平台便利性 傳統模擬軟體（如 ROS 或 Gazebo）安裝過程極其複雜。瀏覽器模擬的優勢在於「免安裝」，只需傳送一個網址，任何裝置（手機、平板、筆電）都能即時觀看機器人的動作。 \n 3. 輕量化的教學與展示 對於初學者來說，瀏覽器是最好的實驗場。透過 Brython 這類工具，我們可以直接用 Python 撰寫邏輯並在網頁上視覺化。這讓技術展示不再只是枯燥的文字紀錄，而是看得見的動態成果。 \n', 'tags': '', 'url': '在瀏覽器中模擬機器人作動的目的是什麼？.html'}, {'title': 'WH14心得', 'text': '41423108:這堂課學到用 Brython 在瀏覽器跑模擬，最方便的就是免安裝跟不怕撞。我們在網頁上把動作邏輯調好，就算寫錯也不會弄壞實體機器人，而且做完只要傳個網址就能給老師看，這種快速驗證、方便分享的感覺真的很實用。 \n 41423101:我認為在瀏覽器模擬機器人能讓學習更安全又直觀，不用擔心硬體損壞，也方便教學與展示，讓初學者更容易理解與嘗試。 \n', 'tags': '', 'url': 'WH14心得.html'}, {'title': 'WH17', 'text': '', 'tags': '', 'url': 'WH17.html'}, {'title': '模擬一brython', 'text': "gh repo clone mdecycu/brython_proj 1 \n cd 1 \n python app.py \n cd /workspaces/cp_final_ex code app.py \n if __name__ == '__main__':  app.run(debug=True, port=main) \n \n \n \n", 'tags': '', 'url': '模擬一brython.html'}, {'title': '模擬二point circle', 'text': "gh repo clone mdecycu/cp_final_ex 2 \n cd /workspaces/cp_final_ex \n python app.py \n cd /workspaces/cp_final_ex code app.py \n if __name__ == '__main__': app.run(debug=True, port=5001) \n \n 模擬三angrybird \n gh repo clone mdecycu/angrybird 3 \n cd /workspaces/angrybird \n python app.py \n cd /workspaces/cp_final_ex code app.py \n if __name__ == '__main__':  app.run(debug=True, port=5002) \n \n \n", 'tags': '', 'url': '模擬二point circle.html'}, {'title': 'WH18', 'text': '\n \n \n \n', 'tags': '', 'url': 'WH18.html'}]};